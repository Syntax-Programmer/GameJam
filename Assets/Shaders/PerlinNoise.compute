#pragma kernel CSMain

// Output texture
RWTexture2D<float4> Result;

// Parameters
float _Time;
float _Scale;
float _TimeScale;
int _Octaves;
float _Persistence;

// Hash function for gradients
float2 hash2(float2 p)
{
    float n = sin(dot(p, float2(127.1, 311.7))) * 43758.5453;
    return frac(float2(n, n * 1.3)) * 2.0 - 1.0;
}

float fade(float t)
{
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float perlin(float2 p)
{
    float2 i = floor(p);
    float2 f = frac(p);

    float2 u = float2(fade(f.x), fade(f.y));

    float2 g00 = hash2(i + float2(0, 0));
    float2 g10 = hash2(i + float2(1, 0));
    float2 g01 = hash2(i + float2(0, 1));
    float2 g11 = hash2(i + float2(1, 1));

    float n00 = dot(g00, f - float2(0, 0));
    float n10 = dot(g10, f - float2(1, 0));
    float n01 = dot(g01, f - float2(0, 1));
    float n11 = dot(g11, f - float2(1, 1));

    float nx0 = lerp(n00, n10, u.x);
    float nx1 = lerp(n01, n11, u.x);

    return lerp(nx0, nx1, u.y);
}

float fbm(float2 p)
{
    float value = 0;
    float amplitude = 1;
    float frequency = 1;
    float maxValue = 0;

    for (int i = 0; i < _Octaves; i++)
    {
        value += amplitude * perlin(p * frequency);
        maxValue += amplitude;
        amplitude *= _Persistence;
        frequency *= 2;
    }
    return value / maxValue;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    if (id.x >= width || id.y >= height)
        return;

    float2 uv = float2(id.xy) / float2(width, height);
    uv *= _Scale;
    uv += _Time * _TimeScale;

    float n = fbm(uv);
    n = n * 0.5 + 0.5; // normalize 0-1

    Result[id.xy] = float4(n, n, n, 1);
}
